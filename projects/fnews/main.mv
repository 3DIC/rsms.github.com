debug = document.location.hostname == 'rmbp2.local'

state = {
  newsFeedItems: [],  # fifo queue (oldest first, newest last)
  lastFeedItemTimestamp: null,
  activeView: null,
}

# Shrink font size until a view is at least *high*
shrink = ^(view, height, callback){
  if (view.height() <= height) {
    view.addClass 'shrunken'
    return setTimeout ^{ callback && callback() }, 1
  }
  fontsize = parseInt view.css 'font-size'
  view.css('font-size', (fontsize - 2) + 'px')
  #setTimeout ^{ shrink(view, height, callback) }, 1
  shrink view, height, callback
}

mapImageStyleParam = ^(style){
  # feature:all%7Celement:all%7Clightness:0%7Cgamma:0.3%7Csaturation:-60
  e = encodeURIComponent
  style = Object.keys(style).map ^(k) { e(k) + "%3A" + e(style[k]) }
  style.join '%7C'
}

mapImageURL = ^(lon, lat) {
  "http://maps.google.com/maps/api/staticmap?"+
      "markers=color:yellow%7C"+lon+","+lat+
      "&style="+mapImageStyleParam({
        feature: "all",
        element: "all",
        lightness: 0,
        gamma: 0.3,
        saturation: -60
      })+
      "&zoom=12"+
      "&size=480x480"+
      "&maptype=road"+
      "&sensor=false"
}

smallMapImageURL = ^(lon, lat) {
  "http://maps.google.com/maps/api/staticmap?"+
      "markers=color:yellow|size:small|"+lon+","+lat+
      "&style="+mapImageStyleParam({
        feature: "all",
        element: "all",
        lightness: 0,
        gamma: 0.3,
        saturation: -60
      })+
      "&zoom=1"+
      "&size=90x90"+
      "&maptype=terrain"+
      "&sensor=false"
}

fbObjectImageURL = ^(user_id) {
  "https://graph.facebook.com/"+user_id+"/picture?type=large"
}

viewControllers = {
  'item.generic': ^(view, item){
    created = new Date(item.created_time)
    item.created_time = created.toTimeString().split(':')[:2].join(':')
    
    #
    # There are two fields which are required:
    # - name (shown top-left)
    # - description (shown large in the center)
    #
    # Conversions and priority:
    # - If there's a "message" parameter, it will be added to the end of a
    #   "description" field, separated by a emdash
    #
    
    # Status item
    if (item.type == 'status' && !item.name) {
      # Use the sender's name and picture as the item name and picture
      item.name = item.from.name
      item.picture = fbObjectImageURL item.from.id
    }
    
    # Photo item
    if (item.type == 'photo') {
      # Get a large image from the graph API if the photo is in the graph
      if (item.object_id)
        item.large_picture = fbObjectImageURL item.object_id
      else
        item.large_picture = item.picture

      # Make sure "name" and "description" parameters are defined
      if (!item.name) item.name = 'Photo'
      if (!item.message && !item.description) item.description = ''
    }
    
    # Link item
    if (item.type == 'link') {
    
      # Instagram
      if (item.application && item.application.id == '124024574287414') {
        item.large_picture = item.link + 'media'
      }
    
      # Foursquare
      if (item.application && item.application.id == '86734274142') {
        if (m = /mapproxy%2F([0-9\.]+)%2F([0-9\.]+)%2Fmap/.exec picture) {
          item.large_picture = mapImageURL m[1], m[2]
          item.picture = smallMapImageURL m[1], m[2]
        }
      }
    }
    
    # If there's a name but no description, assign name to description
    hasDescription = item.description && Text(item.description).trim() != ''
    if (item.name && !hasDescription) {
      item.description = item.name
    }

    # Make text nodes of all properties in the view
    for (k in item) {
      view.find('.__'+k).text item[k]
    }
    
    # If there's a message, it's appended to or replaces description
    if (item.message && Text(item.message).trim() != '') {
      if (hasDescription) {
        e = document.createElement 'em'
        e.appendChild document.createTextNode ' â€” '+item.message
        view.find('.__description').append e
      } else {
        view.find('.__description').text item.message
      }
    }
    
    # Show a large picture (next to the description) if there's one
    if (item.large_picture) {
      view.find('content img').show().attr('src', item.large_picture)
      view.find('content .__description').css('max-width', '480px')
    } else {
      view.find('content img').hide()
      view.find('content .__description').css('max-width', '100%')
    }
    
    # Show a small picture (top-left corner) if there's one
    if (item.picture)
      view.find('.object img').show().attr('src', item.picture)
    else
      view.find('.object img').hide()
    
    # Render sender's picture and name
    user = item.from
    view.find('user picture').css('background-image',
        "url('"+fbObjectImageURL(user.id)+"')")
    view.find('user .name').text(user.name)
    
    # Shrink name and description until they fit in the view
    shrink view.find('.object .__name'), 90, ^{
      shrink view.find('.__description'), 480
    }
    
    # TODO: This like thing needs _a lot_ of work
    #
    # - Currently the "like" is performed as if the app itself say "I like"
    # - We really want the user to "like", not the app
    # - Doing so requires authing the user (again?) to aquire the users oauth
    #   access_token
    #
    view.find('a.like').click ^{
      print 'Liking...'
      FB.api '/'+item.id+'/likes', 'post', params, ^(response) {
        if (response.error)
          print 'Failed to like', response
        else
          print 'Liked', response
      }
      false
    }
    
    # Trigger the "move in" CSS animation
    view.addClass 'moveIn'
  }
}

onNewFeedItems = ^{
  item = state.newsFeedItems.pop()
  print 'onNewFeedItems', item
  
  # Pick a view and controller for the item
  view = $ 'item.'+item.type
  controller = viewControllers['item.'+item.type]
  if (!controller || view.length == 0) {
    # No custom view for this type -- let's use the generic view
    view = $ 'item.generic'
    controller = viewControllers['item.generic']
  }
  
  # Hide any previously active view
  if (state.activeView) {
    state.activeView.addClass 'moveOut'
    setTimeout ^{ $('item.moveOut').remove() }, 1000
  }

  # Make a copy of the view
  view2 = view.clone()
  view.parent().append(view2)
  view = view2

  # Run the controller and mark the view as being active
  controller view, item
  state.activeView = view
}

updateNewsFeed = ^{
  # Clear our timer and setup request parameters
  clearTimeout state.updateNewsFeedTimer
  params = {
    limit: 25,
    date_format: 'r',
  }
  
  # Types of items that we care about -- any other kind is ignored
  acceptedItemTypes = ['link', 'status', 'photo']

  # Add "since" if applicable
  if (state.lastFeedItemTimestamp)
    params.since = state.lastFeedItemTimestamp

  FB.api '/me/home', params, ^(response) {
    print '/me/home ->', response
    $('spinner').addClass 'hidden'
    items = response.data
    #$('body').css({'font-family': 'monospace', 'white-space':'pre'}).text JSON items
    
    # Keep track of last timestamp
    if (items.length)
      state.lastFeedItemTimestamp = items[0].created_time

    # Filter out anything other than links
    items = items.filter ^(item) { acceptedItemTypes.indexOf(item.type) != -1 }

    # Update items state if any new items have appeared
    if (items.length) {
      state.newsFeedItems = state.newsFeedItems.concat items.reverse()

      # Trigger "new item" event
      onNewFeedItems()
    }
    
    # Schedule next query to trigger in 1 minute
    state.updateNewsFeedTimer = setTimeout updateNewsFeed, 60000
  }
}

onUserDidChange = ^{
  updateUserInfo()
  if (state.session) onUserDidLogin(); else onUserDidLogout();
}

onUserDidLogout = ^{
  clearTimeout state.updateNewsFeedTimer

  # Reset state
  state.lastFeedItemTimestamp = null
  if (state.activeView) {
    state.activeView.remove()
    state.activeView = null
  }
  state.newsFeedItems = []
}

onUserDidLogin = ^{
  hideSettings()
  updateNewsFeed()
}

hideSettings = ^{
  $('settings').removeClass('visible').removeClass('hq')
}

showSettings = ^{
  $('settings').addClass 'visible'
  setTimeout ^{ $('settings').addClass 'hq' }, 250
}

updateUserInfo = ^{
  state.user = null
  fields = ["bio", "first_name", "id", "last_name", "link", "name", "timezone"]
  if (state.session) {
    # Fetch the current user's details
    FB.api '/me', ^(user) {
      state.user = user
      print '/me ->', user
      fields.forEach ^(key) { $('.fb-user-'+key).text(user[key]) }
    }
  } else {
    # Clear any user data from the UI
    fields.forEach ^(key) { $('.fb-user-'+key).text("") }
  }
}

updateLoginStatus = ^(session) {
  print 'updateLoginStatus:', session
  if (state.session == session) return  # noop
  old_uid = state.session ? state.session.uid : null
  state.session = session

  if (session) {
    $('.logged-in').show()
    $('.logged-out').hide()
  } else {
    $('.logged-in').hide()
    $('.logged-out').show()
    showSettings()
  }

  if (!state.user || !session || session.uid != old_uid)
    onUserDidChange()
}

FB.init {
  appId: debug ? '175094159205629' : '146624058735944',
  status: true, cookie: true, xfbml: true
}
FB.getLoginStatus ^(response) {
  print 'FB.getLoginStatus ->', response
  updateLoginStatus response.session
}
FB.Event.subscribe('auth.sessionChange', ^(response) {
  print 'event: auth.sessionChange ->', response
  updateLoginStatus response.session
});

L = document.location
baseURL = L.protocol + '//' + L.host + L.pathname + L.search

# Login button
window.ok2login = true
$('settings a.login').click ^{
  if (window.ok2login) {
    window.ok2login = false
    setTimeout ^{ window.ok2login = true }, 1000
    //fbhack(true);
    
    if (window.navigator.standalone) {
      # redirect for iOS in full-screen mode
      document.location.href = 'https://www.facebook.com/dialog/oauth/?'+
          'scope=read_stream'+
          '&client_id='+FB._apiKey+
          '&redirect_uri='+encodeURIComponent(baseURL)+
          '&response_type=token'
    } else {
      # Pop-up for everything else. Note: FB auth can not run in iframes
      FB.login(^(response) {
        print 'FB.login ->', response
        if (response.session) print 'auth success'; else print 'auth fail'
        updateLoginStatus response.session
      }, {perms:'read_stream'})
    }
    
  }
  false
}


# Logout button
$('a.logout').click ^{
  FB.logout ^(response) { print 'FB.logout ->', response }
  false
}

# Settings
settingsIsVisible = false
$('a.settings-tab').click ^{
  if (!settingsIsVisible) {
    settingsIsVisible = true
    showSettings()
    $(this).addClass 'active'
  } else {
    settingsIsVisible = false
    hideSettings()
    $(this).removeClass 'active'
  }
  false
}

# Set orientation class on <html>
window.onorientationchange = ^{
  $('html').attr('class', 'orientation'+window.orientation)
}
window.onorientationchange()


/*keys = [];
for (k in window) keys.push ""+k
keys.sort()
for (k=0; k<keys.length; k++) {
  $('#window').append '<li><b>'+keys[k]+'</b>: '+window[keys[k]]+'</li>'
}
keys = [];
for (k in document) keys.push ""+k
keys.sort()
for (k=0; k<keys.length; k++) {
  $('#document').append '<li><b>'+keys[k]+'</b>: '+document[keys[k]]+'</li>'
}*/