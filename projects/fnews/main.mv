state = {
  newsFeedItems: [],  # fifo queue (oldest first, newest last)
  lastFeedItemTimestamp: null,
  activeView: null,
}

# Shrink font size until a view is at least *high*
shrink = ^(view, height, callback){
  if (view.height() <= height)
    return setTimeout ^{ callback && callback() }, 1
  fontsize = parseInt view.css 'font-size'
  view.css('font-size', (fontsize - 2) + 'px')
  #setTimeout ^{ shrink(view, height, callback) }, 1
  shrink view, height, callback
}

viewControllers = {
  'item.link': ^(view, item){
    created = new Date(item.created_time)
    item.created_time = created.toTimeString().split(':')[:2].join(':')
    
    # Instagram specifics
    if (item.application && item.application.id == '124024574287414') {
      item.large_picture = item.link + 'media'
    }
    
    if (item.name &&
        (!item.description || Text(item.description).trim() == '')) {
      item.description = item.name
    }
    
    if (item.message && Text(item.message).trim() != '') {
      item.description = item.message
    }

    for (k in item) {
      view.find('.__'+k).text item[k]
    }
    
    if (item.large_picture) {
      view.find('content img').show().attr('src', item.large_picture)
      view.find('content .__description').css('max-width', '480px')
    } else {
      view.find('content img').hide()
      view.find('content .__description').css('max-width', '100%')
    }
    
    if (item.picture)
      view.find('.object img').show().attr('src', item.picture)
    else
      view.find('.object img').hide()
    
    user = item.from
    view.find('user picture').css('background-image',
        "url('https://graph.facebook.com/"+user.id+"/picture?type=large')")
    view.find('user .name').text(user.name)
    
    shrink view.find('.object .__name'), 90, ^{
      shrink view.find('.__description'), 480
    }
    
    # TODO: This like thing needs _a lot_ of work
    #
    # - Currently the "like" is performed as if the app itself say "I like"
    # - We really want the user to "like", not the app
    # - Doing so requires authing the user (again?) to aquire the users oauth
    #   access_token
    #
    view.find('a.like').click ^{
      print 'Liking...'
      FB.api '/'+item.id+'/likes', 'post', params, ^(response) {
        if (response.error)
          print 'Failed to like', response
        else
          print 'Liked', response
      }
      false
    }
    
    view.addClass 'moveIn'
  }
}

onNewFeedItems = ^{
  item = state.newsFeedItems.pop()
  print 'onNewFeedItems', item
  
  # Pick a view and controller for the item
  view = $ 'item.'+item.type
  controller = viewControllers['item.'+item.type]
  if (!controller || view.length == 0) {
    # No custom view for this type -- let's use the generic view
    view = $ 'item.generic'
    controller = viewControllers['item.generic']
  }
  
  # Hide any previously active view
  if (state.activeView) {
    state.activeView.addClass 'moveOut'
    oldView = state.activeView
    setInterval ^{ oldView.remove() }, 1000
  }

  # Make a copy of the view
  view2 = view.clone()
  view.parent().append(view2)
  view = view2

  # Run the controller and mark the view as being active
  controller view, item
  state.activeView = view
}

updateNewsFeed = ^{
  # Clear our timer and setup request parameters
  clearTimeout state.updateNewsFeedTimer
  params = {
    limit: 25,
    date_format: 'r',
  }

  # Add "since" if applicable
  if (state.lastFeedItemTimestamp)
    params.since = state.lastFeedItemTimestamp

  FB.api '/me/home', params, ^(response) {
    print '/me/home ->', response
    $('spinner').addClass 'hidden'
    items = response.data
    #$('body').css({'font-family': 'monospace', 'white-space':'pre'}).text JSON items
    
    # Keep track of last timestamp
    if (items.length)
      state.lastFeedItemTimestamp = items[0].created_time

    # Filter out anything other than links
    items = items.filter ^(item) { item.type == 'link' }

    # Update items state if any new items have appeared
    if (items.length) {
      state.newsFeedItems = state.newsFeedItems.concat items.reverse()

      # Trigger "new item" event
      onNewFeedItems()
    }
    
    # Schedule next query to trigger in 1 minute
    state.updateNewsFeedTimer = setTimeout updateNewsFeed, 60000
  }
}

onUserDidChange = ^{
  updateUserInfo()
  if (state.session) onUserDidLogin(); else onUserDidLogout();
}

onUserDidLogout = ^{
  clearTimeout state.updateNewsFeedTimer

  # Reset state
  state.lastFeedItemTimestamp = null
  if (state.activeView) {
    state.activeView.remove()
    state.activeView = null
  }
  state.newsFeedItems = []
}

onUserDidLogin = ^{
  hideSettings()
  updateNewsFeed()
}

hideSettings = ^{
  $('settings').removeClass('visible').removeClass('hq')
}

showSettings = ^{
  $('settings').addClass 'visible'
  setTimeout ^{ $('settings').addClass 'hq' }, 250
}

updateUserInfo = ^{
  state.user = null
  fields = ["bio", "first_name", "id", "last_name", "link", "name", "timezone"]
  if (state.session) {
    # Fetch the current user's details
    FB.api '/me', ^(user) {
      state.user = user
      print '/me ->', user
      fields.forEach ^(key) { $('.fb-user-'+key).text(user[key]) }
    }
  } else {
    # Clear any user data from the UI
    fields.forEach ^(key) { $('.fb-user-'+key).text("") }
  }
}

updateLoginStatus = ^(session) {
  print 'updateLoginStatus:', session
  if (state.session == session) return  # noop
  old_uid = state.session ? state.session.uid : null
  state.session = session

  if (session) {
    $('.logged-in').show()
    $('.logged-out').hide()
  } else {
    $('.logged-in').hide()
    $('.logged-out').show()
    showSettings()
  }

  if (!state.user || !session || session.uid != old_uid)
    onUserDidChange()
}

FB.init {appId: '146624058735944', status: true, cookie: true, xfbml: true}
FB.getLoginStatus ^(response) {
  print 'FB.getLoginStatus ->', response
  updateLoginStatus response.session
}
FB.Event.subscribe('auth.sessionChange', ^(response) {
  print 'event: auth.sessionChange ->', response
  updateLoginStatus response.session
});

L = document.location
baseURL = L.protocol + '//' + L.host + L.pathname + L.search

# Login button
window.ok2login = true
$('settings a.login').click ^{
  if (window.ok2login) {
    window.ok2login = false
    setTimeout ^{ window.ok2login = true }, 1000
    //fbhack(true);
    
    if (window.navigator.standalone) {
      # redirect for iOS in full-screen mode
      document.location.href = 'https://www.facebook.com/dialog/oauth/?'+
          'scope=read_stream'+
          '&client_id='+FB._apiKey+
          '&redirect_uri='+encodeURIComponent(baseURL)+
          '&response_type=token'
    } else {
      # Pop-up for everything else. Note: FB auth can not run in iframes
      FB.login(^(response) {
        print 'FB.login ->', response
        if (response.session) print 'auth success'; else print 'auth fail'
        updateLoginStatus response.session
      }, {perms:'read_stream'})
    }
    
  }
  false
}


# Logout button
$('a.logout').click ^{
  FB.logout ^(response) { print 'FB.logout ->', response }
  false
}

# Settings
settingsIsVisible = false
$('a.settings-tab').click ^{
  if (!settingsIsVisible) {
    settingsIsVisible = true
    showSettings()
    $(this).addClass 'active'
  } else {
    settingsIsVisible = false
    hideSettings()
    $(this).removeClass 'active'
  }
  false
}

# Set orientation class on <html>
window.onorientationchange = ^{
  $('html').attr('class', 'orientation'+window.orientation)
}
window.onorientationchange()


/*keys = [];
for (k in window) keys.push ""+k
keys.sort()
for (k=0; k<keys.length; k++) {
  $('#window').append '<li><b>'+keys[k]+'</b>: '+window[keys[k]]+'</li>'
}
keys = [];
for (k in document) keys.push ""+k
keys.sort()
for (k=0; k<keys.length; k++) {
  $('#document').append '<li><b>'+keys[k]+'</b>: '+document[keys[k]]+'</li>'
}*/